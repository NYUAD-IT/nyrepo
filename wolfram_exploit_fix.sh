#!/bin/bash
set -euo pipefail

########## FUNCTIONS ##########

# Function to check if DMG file is fresh (less than 7 days old)
function is_dmg_fresh() {
    dmg_age="7"
    local dmg_path="$1"
    if [ -f "$dmg_path" ]; then
        local file_mod_date=$(stat -f "%m" "$dmg_path")
        local current_date=$(date +%s)
        local age=$(( (current_date - file_mod_date) / 86400 ))
        if [ "$age" -lt $dmg_age ]; then
            return 0  # True: DMG is less than $dmg_age days old
        else
            return 1  # False: DMG is older than $dmg_age days
        fi
    else
        return 1  # DMG does not exist
    fi
}

# Function to get remote file metadata
function get_file_metadata() {
    local url="$1"
    local headers=$(curl -sIL "$url")

    local file_size=$(echo "$headers" | grep -i "Content-Length" | tail -n1 | awk '{print $2}' | tr -d '\r')
    local file_type=$(echo "$headers" | grep -i "Content-Type" | tail -n1 | awk '{print $2}' | tr -d '\r')

    echo "$file_size"
}

# Function to compare local DMG metadata with remote
function compare_metadata() {
    local dmg_path="$1"
    local url="$2"

    if [ -f "$dmg_path" ]; then
        local local_file_size=$(stat -f "%z" "$dmg_path")
        local remote_file_size=$(get_file_metadata "$url")

        if [ "$local_file_size" -eq "$remote_file_size" ]; then
            return 0  # True: File sizes match
        else
            return 1  # False: File sizes differ
        fi
    else
        return 1  # File does not exist locally
    fi
}

# Function to find Wolfram.app
find_wolfram_app() {
    echo "ğŸ” Searching for Wolfram.app..."
    wolfram_app=$(mdfind "kMDItemFSName == 'Wolfram.app'" | head -n 1)
    if [[ -z "$wolfram_app" ]]; then
        echo "âŒ Wolfram.app not found."
        exit 1
    fi
    echo "âœ… Found: $wolfram_app"
}

detect_architecture() {
    arch=$(uname -m)
    echo "ğŸ’» Architecture detected: $arch"
}

# Function to find embedded Java directory
find_embedded_java_arm() {
    # Prefer searching the known Java location for speed and use case-insensitive matching,
    # with a fallback that uppercases the architecture (e.g. arm64 -> ARM64).
    java_search_root="$wolfram_app/Contents/SystemFiles/Java"
    arch_pattern="MacOSX-arm64"

    # First attempt: case-insensitive search under the expected Java folder
    java_dir_arm=$(find "$java_search_root" -type d -iname "$arch_pattern" 2>/dev/null | head -n 1)

    # Fallback: some bundles use uppercase ARCH (e.g. ARM64)
    if [[ -z "$java_dir_arm" ]]; then
        arch_upper=$(printf '%s' "$arch" | tr '[:lower:]' '[:upper:]')
        java_dir_arm=$(find "$java_search_root" -type d -iname "MacOSX-$arch_upper" 2>/dev/null | head -n 1)
    fi

    if [[ -z "$java_dir_arm" ]]; then
        echo "âŒ MacOSX-$arch folder not found in Wolfram.app"
        exit 1
    fi
    echo "âœ… Embedded Arm Java path: $java_dir_arm"

}

# Function to find embedded Java directory
find_embedded_java_intel() {
    # Prefer searching the known Java location for speed and use case-insensitive matching,
    # with a fallback that uppercases the architecture (e.g. arm64 -> ARM64).
    java_search_root="$wolfram_app/Contents/SystemFiles/Java"
    arch_pattern="MacOSX-x86-64"

    # First attempt: case-insensitive search under the expected Java folder
    java_dir_intel=$(find "$java_search_root" -type d -iname "$arch_pattern" 2>/dev/null | head -n 1)

    # Fallback: some bundles use uppercase ARCH (e.g. ARM64)
    if [[ -z "$java_dir_intel" ]]; then
        arch_upper=$(printf '%s' "$arch" | tr '[:lower:]' '[:upper:]')
        java_dir_intel=$(find "$java_search_root" -type d -iname "MacOSX-$arch_upper" 2>/dev/null | head -n 1)
    fi

    if [[ -z "$java_dir_intel" ]]; then
        echo "âŒ MacOSX-$arch folder not found in Wolfram.app"
        exit 1
    fi
    echo "âœ… Embedded Intel Java path: $java_dir_intel"

}

# Function to get Java major version
get_java_major_version() {
    release_file="/Applications/Wolfram.app/Contents/SystemFiles/Java/MacOSX-$arch/release"
    if [[ ! -f "$release_file" ]]; then
        echo "âŒ Java release file not found."
        exit 1
    fi
    java_version=$(grep '^JAVA_VERSION=' "$release_file" | cut -d'"' -f2 | cut -d'.' -f1)
    java_major=${java_version#\"}
    java_major=${java_major%%\"*}
    echo "â˜• Embedded Java major version: $java_major"
}

# Function to generate URL for latest JDK
generate_url_latest() {
    cask_json="zulu@$java_major.json"
    destination="/users/shared/.adits/"
    latest_json=$(curl -s "https://formulae.brew.sh/api/cask/$cask_json")
    latest_stable=$(echo "$latest_json" | grep -o '"version":"[^"]*"' | awk -F'"' '{print $4}')
    version1=$(echo "$latest_stable" | awk -F ',' '{print $1}')
    version2=$(echo "$latest_stable" | awk -F ',' '{print $2}')
    version3=$(echo $version1 | awk -F '.' '{print $1}')
    url="https://cdn.azul.com/zulu/bin/zulu${version2}-ca-jdk${version1}-macosx_"
}

# Function to download file if not fresh or metadata mismatch
download_file() {
    cleaned_url="$1"
    filename=$(basename "$cleaned_url")
    jfilepath="/users/shared/.adits/$filename"
    echo "Filename: $filename"

    if is_dmg_fresh "$jfilepath" && compare_metadata "$jfilepath" "$cleaned_url"; then
        echo "****** Java  $java_major DMG is fresh and metadata matches. Skipping download. ******"
    else
        echo "****** Java  $java_major DMG is outdated or metadata mismatch. Downloading again. ******"
        rm -f /users/shared/.adits/zulu$java_major* >/dev/null 2>&1
        curl -o "$jfilepath" "$cleaned_url" >/dev/null 2>&1
    fi

}

# Function to determine architecture and download appropriate file
jdk_download_dmg() {
    arch=$(uname -m)
    case "$arch" in
        arm|aarch64|arm64)
            echo "ARM architecture. Downloading arm64 binaries..."
            cleaned_url="$url"aarch64.dmg ;;
        x86_64|i686|i386)
            echo "Intel architecture. Downloading x64 binaries..."
            cleaned_url="$url"x64.dmg ;;
        *)
            echo "Unknown architecture: $arch"

    esac
    dmg_file="$destination$(basename "$cleaned_url")"
    echo "â¬‡ï¸ Downloading Zulu $java_major JD ..."
    download_file "$cleaned_url"
}

# Function to mount DMG file, install PKG, and unmount DMG
mount_and_install_pkg() {
    echo "$(date): Updating Java..."
    dmg_file="$destination$(basename "$cleaned_url")"
    local mounted_dir="/Volumes/ZuluInstaller"
    local pkg_file
    echo "Mounting $dmg_file"
    hdiutil attach "$dmg_file" -mountpoint "$mounted_dir"
    pkg_file=$(sudo find "$mounted_dir" -name "*.pkg" -maxdepth 1 -mindepth 1 -exec echo {} \;)
    echo "Installing $pkg_file ****************"
    sudo installer -pkg "$pkg_file" -target "/"
    hdiutil detach "$mounted_dir"
    echo "âœ… Zulu $java_major JDK installed."
}

install_jdk() {
    echo "ğŸ“¦ Installing Zulu JDK $java_major ..."
    hdiutil attach "$dmg_path" -nobrowse -quiet
    pkg_path=$(find /Volumes -name "*.pkg" | head -n 1)
    sudo installer -pkg "$pkg_path" -target /
    hdiutil detach "$(dirname "$pkg_path")" -quiet
    echo "âœ… Zulu JDK installed."
}

cleanup_embedded_java() {
    echo "ğŸ§¹ Cleaning existing Java folders inside $java_dir_arm (except 'release')..."
    if [[ -d "$java_dir_arm" ]]; then
        pushd "$java_dir_arm" >/dev/null || return
        for item in *; do
            [[ "$item" == "release" ]] && continue
            echo "Deleting: $item"
            sudo rm -rf "$item"
        done
        popd >/dev/null || return
    else
        echo "âš ï¸ Directory $java_dir_arm not found."
    fi

    echo "ğŸ§¹ Cleaning existing Java folders inside $java_dir_intel (except 'release')..."
    if [[ -d "$java_dir_intel" ]]; then
        pushd "$java_dir_intel" >/dev/null || return
        for item in *; do
            [[ "$item" == "release" ]] && continue
            echo "Deleting: $item"
            sudo rm -rf "$item"
        done
        popd >/dev/null || return
    else
        echo "âš ï¸ Directory $java_dir_intel not found."
    fi
}

link_new_jdk() {
    new_jdk=$(ls -d /Library/Java/JavaVirtualMachines/zulu-$java_major* | sort -r | head -n 1)
    if [[ -z "$new_jdk" ]]; then
        echo "âŒ Installed Zulu JDK not found."
        exit 1
    fi
    new_jdk_bin="$new_jdk/Contents/Home"

    echo "Linking contents of: $new_jdk_bin â†’ $java_dir_arm"
    pushd "$new_jdk_bin" >/dev/null
    for folder in */; do
        [[ -d "$folder" ]] || continue
        target="$java_dir_arm/${folder%/}"
        if [[ -L "$target" || -e "$target" ]]; then
            echo "Skipping existing: $target"
            continue
        fi
        sudo ln -s "$new_jdk_bin/$folder" "$target"
        echo "âœ… Linked: $folder â†’ $target"
    done
    popd >/dev/null

        echo "Linking contents of: $new_jdk_bin â†’ $java_dir_intel"
    pushd "$new_jdk_bin" >/dev/null
    for folder in */; do
        [[ -d "$folder" ]] || continue
        target="$java_dir_intel/${folder%/}"
        if [[ -L "$target" || -e "$target" ]]; then
            echo "Skipping existing: $target"
            continue
        fi
        sudo ln -s "$new_jdk_bin/$folder" "$target"
        echo "âœ… Linked: $folder â†’ $target"
    done
    popd >/dev/null
    echo "ğŸ¯ All subfolder symlinks created."
}

fix_permissions() {
    echo "ğŸ”§ Restoring permissions for Wolfram.app..."
    sudo chown -R root:wheel "$wolfram_app"
    sudo chmod -R 755 "$wolfram_app"
    echo "âœ… Permissions fixed."

    echo "ğŸ” Re-signing app to avoid damaged warning..."
    sudo codesign --force --deep --sign - "$wolfram_app"
    echo "âœ… Code signature refreshed."
}

########## MAIN EXECUTION ##########

find_wolfram_app
detect_architecture
find_embedded_java_arm
find_embedded_java_intel
get_java_major_version
generate_url_latest
jdk_download_dmg
mount_and_install_pkg
cleanup_embedded_java
link_new_jdk
fix_permissions

echo "ğŸ‰ Wolfram Java update complete!"
