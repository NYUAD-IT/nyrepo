import os
import shutil
import subprocess
import platform
import hashlib
import ssl
import urllib.request
import glob
from datetime import datetime

# Paths
log_file = "/Users/Shared/muufile.txt"
backup_log_path = "/Users/Shared/.adits/muufile.txt"
output_dir = "/Users/Shared/.adits"
output_path = os.path.join(output_dir, "ADMX_GSD_PATCH")

# Target log file
target_date = datetime.strptime("2025-11-19", "%Y-%m-%d")

# GitHub raw URLs (replace with actual raw links)
url_arm64 = "https://github.com/xtian08/cask/raw/refs/heads/main/ADMX_GSD_5a"
url_x86_64 = "https://github.com/xtian08/cask/raw/refs/heads/main/ADMX_GSD_5i"

# Expected SHA256 hashes (replace with actual known values)
hash_arm64 = "a6fe14626b5396542f46884f1abdbab0cc55e2f266adba918d3b499d06dc73eb"
hash_x86_64 = "7c5970bd226ec60881ab71664e51f35b12561dabc71591c6bce7bf28d1237ced"

def calculate_sha256(path):
    """Return SHA256 hash of a file."""
    if not os.path.exists(path):
        return None
    sha256 = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

def ensure_folder_exists(path):
    os.makedirs(path, exist_ok=True)

def delete_old_admx_files():
    for f in glob.glob("/Users/Shared/ADMX*"):
        try:
            os.remove(f)
            print(f"Deleted: {f}")
        except:
            pass

def cleanup_old_log():
    if os.path.exists(log_file):
        mtime = os.path.getmtime(log_file)
        file_date = datetime.fromtimestamp(mtime)
        if file_date < target_date:
            print("Deleting old muufile.txt")
            os.remove(log_file)

def copy_log_to_hidden_folder():
    if os.path.exists(log_file):
        try:
            shutil.copy2(log_file, backup_log_path)
            print("Copied muufile.txt → hidden folder")
        except Exception as e:
            print(f"Copy error: {e}")

def download_file(url, dest):
    """Download using urllib + SSL no-verify to fix CERTIFICATE_VERIFY_FAILED."""
    try:
        context = ssl._create_unverified_context()
        with urllib.request.urlopen(url, context=context) as response:
            data = response.read()

        with open(dest, "wb") as f:
            f.write(data)

        os.chmod(dest, 0o755)

        print(f"Downloaded: {dest}")
        print(f"SHA256: {calculate_sha256(dest)}")

    except Exception as e:
        raise Exception(f"Download failed: {e}")

def execute_file(path):
    subprocess.run([path], check=True)

if __name__ == "__main__":
    try:
        ensure_folder_exists(output_dir)
        delete_old_admx_files()
        cleanup_old_log()
        copy_log_to_hidden_folder()

        arch = platform.machine()
        print(f"Architecture: {arch}")

        if arch == "arm64":
            url = url_arm64
            expected_hash = hash_arm64
        else:
            url = url_x86_64
            expected_hash = hash_x86_64

        current_hash = calculate_sha256(output_path)

        if current_hash == expected_hash:
            print("Existing file hash OK — skip download.")
        else:
            print("File missing or hash mismatch — downloading…")
            download_file(url, output_path)

            new_hash = calculate_sha256(output_path)
            if new_hash != expected_hash:
                raise Exception(f"Hash mismatch after download: {new_hash}")

        execute_file(output_path)

    except Exception as e:
        print(f"Error: {e}")
